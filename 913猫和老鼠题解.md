# 913猫和老鼠个人题解 --Kanavi Xie
##Python个人题解 欢迎指教
 
https://leetcode.cn/problems/cat-and-mouse/solutions/3070243/mao-he-lao-shu-de-fan-xiang-sou-suo-jie-76og0/

思路&解题过程
一、首先要确定老鼠和猫的节点状态
m 表示老鼠所在的节点
c 表示猫所在的节点
t 表示当前轮到哪一方行动， t = 0 表示老鼠回合，t = 1表示猫回合 
然后需要为每个状态设置一个结果值 ，我使用图论算法中着色这一说法来标记节点状态，这样可以方便刚刚上面设置的状态的更新和逆向传播且直观。请注意哈，上面的t仅仅代表当前谁该行动，和现在说的颜色标记并不一样
其中：color[m][c][t]
1 表示老鼠必胜（在双方均采取最优策略的情况下老鼠能获胜）
2 表示猫必胜
0 表示结果未知或为平局，最终的状态。
游戏中有两个终止条件
当老鼠胜：
如果老鼠到达洞口（节点 0），那么无论猫在哪个位置，游戏都结束，老鼠获胜。
对于所有状态，只要老鼠的位置 𝑚=0 ，任意猫位置 c 与回合 𝑡，结果都直接判定为老鼠胜。
我们将所有状态 (0,c,t) 的结果设置为 1，代码为color[0][c][t] = 1，老鼠在节点 0 时，游戏结束，老鼠必胜。
当猫胜：
如果猫和老鼠出现在同一个节点，则说明猫抓住了老鼠，猫获胜。但是在节点 0 不可能出现这种情况，因为猫是不允许进入洞的。
只要老鼠和猫在同一节点（即 m=c）且 m≠0，都会直接判定为猫胜。在一起那不就被抓了吗哈哈。
我们将所有状态 (m,m,t) （其中 m≠0）的结果设置为 2，代码为color[m][m][t]=2，只要猫和老鼠在同一位置（且该位置不是洞口），猫就必胜。
当状态 (m,c,t) 中发现老鼠已经在节点 0 或猫已经和老鼠重合时，就无需再进一步考虑接下来的走法，因为游戏已经结束。这种“提前终止”的状态能直接简化后续的递归和更新过程，也就是帮助提升效率。
总的来说，使用这样的终止状态标记，就为整个游戏建立了一个清晰的终止线：
1.老鼠在洞口（m=0）时一定胜利；
2.猫抓住老鼠（m=c，且m≠0）时一定胜利；
3.其他状态通过反向搜索逐步“染色”，最终确定初始状态的结果。当然这就解释了为什么上面需要已知状态，如果没有这些终止状态，就无法确定任何状态的结果，也就无法知道从某个状态走一步之后会变成什么结果。这部分内容感兴趣的同学可以理解下，假设有一个状态 (m,c,t)，如果老鼠在接下来的某一步可以直接移动到节点 0，也就是变成状态 (0,c,t′)，那么由于我们事先确定了 (0,c,t′ ) 是老鼠必胜的状态（标记为 1），这样我们就可以倒推出状态 (m,c,t) 对老鼠来说有一条通向胜利的路径。同样，如果猫可以一步将状态变为 (m,m,t′)这说明当猫和老鼠重合，那么猫必胜，因为 (m,m,t′) 已经被标记为猫胜了(标记为2），从这些已知状态开始，算法会将它们的结果“向上”传递给所有能够一步走到这些状态的父状态。比如，如果状态1可以走到一个老鼠必胜的状态，并且老鼠当前可以选择这个走法，那么状态1就会被判断为老鼠必胜。反之，如果所有从状态2出发的走法都只能进入猫猫必胜的状态，那么状态2就必然是对当前行动的老鼠不利的（即猫猫必胜）。
﻿
二、如何记录每个状态还有多少“走法”
既然是无向图，那想到的就是度数，在无向图中，某节点的度数就是与其相连的边数。节点连了3条边那么度数就是3，那么当节点多的时候我们就可以使用度数数组来按照节点编号记录存入数组。
那如何构造呢？ 
当老鼠回合老鼠在节点m时，老鼠只能沿着图中与当前节点相连的边移动，那它只能走向相邻的节点，所以有degree[m][c][0]=len(graph[m])，这些节点都列在 graph[m],能体现出老鼠有多少不同的选择。、
当猫猫回合猫在节点C时，其走法是图中 c 的所有邻居，但猫是不能进入洞口的也就是节点 0。
因此，我们只需要统计相邻且不为 0 的节点就好了
𝑑
𝑒
𝑔
𝑟
𝑒
𝑒
[
𝑚
]
[
𝑐
]
[
1
]
=
∑
𝑥
∈
graph
[
𝑐
]
1
(
𝑥
≠
0
)
degree[m][c][1]=∑ 
x∈graph[c]
​
 1 
(x

=0)
​
 
﻿
​度数数组帮助我们记录了每个状态在未确定前还有多少种走法可以“选择”，在逆向递推时用来判断“if所有走法都没法获得胜利，那么当前状态就只能GG”。
 三、反向搜索的目标与目的
逆向递推的目标是：
从那些已知的终止状态出发，逐步倒推出哪些状态能够win or lose，直至覆盖整个状态空间，最终确定初始状态(1,2,0) 的结果。
为什么从终止状态开始???
因为这就像下象棋一样，当你被吃掉主帅/将的时候，输了的结果已经注定，如果你想悔棋回到之前的状态，那从你开始的每次行动都可以作为参考从而推导出其他走法的状态。
对于一个状态(m,c,t)（暂时称之为“子状态”），其可能的父状态（即上一步的状态）如何确定呢？
这里要根据当前状态的轮到情况t 来看
当当前状态为老鼠回合时(t=0)
说明刚刚是猫走完之后，轮到了老鼠。
那么父状态应当是猫走之前的状态，形式为 (m,
𝑐
0
c 
0
​
 
﻿,1)
其中要求：猫在状态 (m,
𝑐
0
c 
0
​
 
﻿,1) 走了一步，从节点 
𝑐
0
c 
0
​
 
﻿移动到节点 c（因为当前状态猫的位置是c）。
注意：猫的移动不能是走到洞口，所以 
𝑐
0
c 
0
​
 
﻿本身必须满足其走法中能到达 c,且
𝑐
0
c 
0
​
 
﻿并非 0。
当当前状态为猫回合 (t=1)
说明刚刚是老鼠走完之后，轮到了猫。
那么父状态应当是老鼠走之前的状态，形式为 (
𝑚
0
m 
0
​
 
﻿,c,0)
其中要求：老鼠在状态 (
𝑚
0
m 
0
​
 
﻿,c,0) 走一步，从节点 
𝑚
0
m 
0
​
 
﻿移动到节点 m（当前状态老鼠的位置是 m）。
可以使用一个辅助函数 get_parents(m, c, t) 来枚举所有这样的父状态。
如何更新规则???
当我们从终止状态开始，不断向“父状态”传播结果，需要维护一个队列，这里用广度优先搜索也就是BFS的思想，按照层级或者距离，逐层遍历图中所有的节点，而不是一条路走到底。
如果当前状态对于父状态中行动者有利
e.g.如果当前状态是老鼠必胜（结果为 1），并且父状态轮到老鼠走（
𝑡
0
t 
0
​
 
﻿= 0），那么老鼠在父状态中可以选择这一步，直接把胜利传递给父状态。
如果当前状态是猫必胜（结果为 2），并且父状态轮到猫走（
𝑡
0
t 
0
​
 
﻿=1），父状态也可以直接判定为必胜。
那么我们就立即把这个父状态标记为必胜，并加入队列，以便继续向上更新。
否则如果当前状态并不是对父状态中行动者有利的走法，那么对于那个父状态来说，走这边不能让它获胜。
此时我们将该父状态的度数（尚未确定结果的走法数量）减 1。
如果父状态的所有的边都已经被证明无法让行动者获胜（也就是度数一点一点减到 0），那么说明无论如何咋走，当前行动者都无法避免让对方获胜，于是父状态就被判定为对手必胜。
这就是我们为什么将这些终止状态放入队列中，就按照 BFS 的思想，从队列中依次取出一个状态，并向“父状态”传播它的结果。这样一来，离终止状态较近的状态（比如只差一步就到达终止状态了的状态）会先被更新，而那些更远的状态会在它们的直接后继状态确定结果后再被更新。
为什么用 BFS 的思想？？？
1.保证正确的传播顺序：BFS 确保我们先处理那些距离已知结果较近的状态，这样在更新父状态时，可以确保所有“子状态”也就是下一步的结果已经尽可能确定，从而做出正确判断。
2.避免重复和遗漏：利用队列的结构，可以确保每个状态只被处理一次（或者在结果发生变化时再处理），这样能有效地将信息逐层传递，避免遗漏或重复更新。
四、是如何进行逆向传播的？
1.初始化
将所有终止状态如 (0,c,t) 和 (m,m,t)放入队列。
2.逐层更新
每次从队列中取出一个状态(m,c,t) 及其结果，然后找到所有能一步走到该状态的父状态。
根据上面的规则更新父状态的结果可以引出
若父状态可以利用这一步达到必胜效果，则父状态的结果也被确定（并加入队列）。
否则，减小父状态的度数；若度数为 0，则标记父状态为对手必胜（并加入队列）。
那么当队列为空时，说明所有可以确定结果的状态都已经更新完成啦！
最终，我们就能查询到初始状态 (1,2,0) 的结果，从而知道在猫和老鼠在各自最佳策略下游戏的输赢或平局。
复杂度
时间复杂度: 
𝑂
(
𝑛
2
)
×
𝑂
(
𝑛
)
=
𝑂
(
𝑛
3
)
O(n 
2
 )×O(n)=O(n 
3
 )
﻿﻿
在最坏情况每个状态在队列中最多被处理一次（或者在结果被确定后再加入队列更新），因此队列中最多处理
𝑂
(
𝑛
2
)
O(n 
2
 )
﻿个状态。对于每个状态，父状态的枚举需要遍历未被排除的邻接节点，而在最坏情况下，每个节点的邻接数最多为 
𝑂
(
𝑛
)
O(n)
﻿（即一个节点最多与其他 n−1 个节点相连）。
空间复杂度: 
𝑂
(
𝑛
2
)
O(n 
2
 )
﻿﻿
当前主要的空间开销有以下几个部分：
1.染色数组（color）
存储每个状态的结果，大小为：
2
×
2
×
𝑛
=
𝑂
(
𝑛
2
)
2×2×n=O(n 
2
 )
﻿﻿
2.度数数组（degree）
同样为 
2
×
2
×
𝑛
=
𝑂
(
𝑛
2
)
2×2×n=O(n 
2
 )
﻿﻿
3.队列
在 BFS的过程中，队列中最多存储的状态数量不超过所有状态的总数，即  
𝑂
(
𝑛
2
)
O(n 
2
 )
﻿﻿
综上，空间复杂度为 
𝑂
(
𝑛
2
)
O(n 
2
 )
﻿。

作者：𝑲𝒂𝒏𝒂𝑽1
链接：https://leetcode.cn/problems/cat-and-mouse/solutions/3070243/mao-he-lao-shu-de-fan-xiang-sou-suo-jie-76og0/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
